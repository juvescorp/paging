/* Задание
 *
 * Проверим, как вы поняли paging. Для этого вам предлагается выступить в качестве процессора и преобразовать несколько логических адресов в физические. Формат входных данных следующий:

в первой строке вам даны 3 числа m,q,r≥0 , где q - это количество запросов, на которые вам нужно ответить, r - физический адрес корневой таблицы страниц
следующих m строках записаны пары paddr и value - описание физической памяти, каждая пара значит, что по физическому адресу paddr хранится 64 битное значение value, при этом гарантируется, что все paddr различны, выровнены на границу 8 байт и помещаются в 64 бита
в последних q строках идут целые числа - логические адреса, которые вам нужно преобразовать в физические, для каждого из этих чисел нужно вывести на отдельной строке либо физический адрес, либо слово "fault", если преобразовать логический адрес в физический нельзя.
Считайте, что таблица страниц имеет формат 64 битного режима x86 (4 уровня, каждая страница 4 KB, каждая запись 8 байт, формат записи был показан в лекциях), но вы можете игнорировать все поля, кроме бита присутствия (на картинке бит P - нулевой бит) и собственно физического адреса.

Для всех физических адресов, не указанных во входных данных (среди m пар paddr value), считайте, что по этим адресам хранятся нули.

ВАЖНО: это было неочевидно из видео, но все физические адреса, которые хранятся в записях таблицы страниц должны быть выровнены, как минимум, на границу 4096 байт (4Kb), т. е. младшие 12 бит физических адресов всегда равны 0, соответственно, хранить младшие биты нет смысла и в записе таблицы страниц они не хранятся - их место занимают специальные флаги. Убедитесь, что вы понимаете приведенный пример.

ВАЖНО2: после каждой неверной попытки вам требуется скачать новый набор данных и использовать его для следующей попытки.
Sample Input:

4 4 0
0 4097
4096 8193
8192 12289
12288 16385
0
4096
42
131313
Sample Output:

16384
fault
16426
fault

*/

#include <stdio.h>
#include <stdlib.h>

void main(){
 int m,q,r; // в первой строке вам даны 3 числа m,q,r≥0 , где q - это количество запросов, на которые вам нужно ответить, r - физический адрес корневой таблицы страниц 
 // следующих m строках записаны пары paddr и value - описание физической памяти, каждая пара значит, что по физическому адресу paddr хранится 64 битное значение value, при этом гарантируется, что все paddr различны, выровнены на границу 8 байт и помещаются в 64 бита
 int paddr[1000000],value[1000000],paddr_tmp,value_tmp,found_tmp;
 int calculated_addr;
 // в последних q строках идут целые числа - логические адреса, которые вам нужно преобразовать в физические, для каждого из этих чисел нужно вывести на отдельной строке либо физический адрес, либо слово "fault", если преобразовать логический адрес в физический нельзя.
// unsigned long long int logaddr[1000000];
// Указатель на логические адреса (выделение памяти под массив будет потом)
 unsigned long long int *logaddr;
// Указатель на физические адреса, преобразованные из логических (выделение памяти будет потом) 
 unsigned long long int *paddr_converted;
// Указатель на смещение в таблице адресов (выделение памяти будет потом) 
 unsigned long long int *offset;
// Указатель на адрес таблицы страниц (выделение памяти будет потом) 
 unsigned long long int *table_addr;
// Указатель на массив флагов ошибки преобразования из логических ошибок в физические (выделение памяти будет потом) 
 unsigned short *fault_flag;
 
 int i=0,j=0;
 FILE *f = fopen("dataset_44327_15.txt","r"); // dataset_44327_15.txt","r"); // Файл с данными открываем для чтения
 FILE *f_output = fopen("result.txt","w");
 fscanf(f, "%d %d %d",&m,&q,&r); // Считываем из файла первую строку с количествами элементов 
 printf("Количество пар \"физический адрес-значение\"     Количество запросов     Физический адрес корневой таблицы страниц \n");				 //
// fprintf(f_output,"Количество пар \"физический адрес-значение\"     Количество запросов     Физический адрес корневой таблицы страниц \n");
 printf("%d %d %d\n\n",m,q,r); // И выводим её для отладки
// fprintf(f_output,"%d %d %d\n\n",m,q,r);
 // Считывание пар "физический адрес - значение" из файла
 printf ("Физический адрес    Значение\n");
// fprintf (f_output,"Физический адрес    Значение\n");
 for (i=0;i<m;i++){
  fscanf(f, "%d %d",&paddr[i],&value[i]); // считываем физический адрес и значение, находящееся по этому адресу
  printf("%d %d\n",paddr[i],value[i]); // И выводим для отладки
 // fprintf (f_output,"%d %d\n",paddr[i],value[i]); 
 }
 printf("\n");
// fprintf(f_output,"\n");
 // Выделение памяти под логические адреса, которые будем считывать
 logaddr = (unsigned long long int*)malloc(q * sizeof(unsigned long long int));
 // Выделение памяти под физические адреса, которые будут получены преобразованием из логических
 paddr_converted = (unsigned long long int*)malloc(q * sizeof(unsigned long long int));
 // Выделение памяти под смещение в таблице адресов
 offset =  (unsigned long long int*)malloc(q * sizeof(unsigned long long int));
 // Выделение памяти под адреса таблиц страниц
 table_addr =  (unsigned long long int*)malloc(q * sizeof(unsigned long long int));
 // Выделение памяти под массив флагов ошибки преобразования из логических ошибок в физические
 fault_flag = (unsigned short*)malloc(q * sizeof(unsigned short));

 // обнуление массива флагов ошибки преобразования из логических адресов в физические
 for (i=0;i<q;i++)
  fault_flag[i]=0;

 // Считывание логических адресов из файла
 printf("Логические адреса:\n");
// fprintf(f_output,"Логические адреса:\n");
 for (i=0;i<q;i++){
  fscanf(f, "%llu",&logaddr[i]); // считываем логический адрес, который нужно перевести в физический
  printf("%llu\n",logaddr[i]); // И выводим для отладки
//  fprintf(f_output,"%llu\n",logaddr[i]);
 }
 printf("\n");
// fprintf(f_output,"\n");
 // Здесь должно быть преобразование логических адресов в физические и вывод результата.
 //
 // Примерный алгоритм ниже
 //
 /* Нужно получить из логического адреса в таблице страниц физический.
 Начинается всё с адреса корневой таблицы страниц, хранящегося в регистре CR3. (переменная r - нужно будет её привязать сюда в код)
 Затем логический адрес (элемент массива logaddr[i] разбивается на 5 частей.
 */
 /* 
 Далее берём первую часть: биты логического адреса logaddr[i] 39-47. 
 Из них получаем смещение в корневой таблице страниц (уровень 4). 
 Это смещение прибавляем к адресу из CR3 и получаем адрес записи.
 */
 printf("\nОбработка таблицы уровня 4\n");
 printf("Адреса в таблице страниц:\n");
// fprintf(f_output,"\nОбработка таблицы уровня 4\n");
// fprintf(f_output,"Адреса в таблице страниц:\n");
 for (i=0;i<q;i++){
  offset[i]= ((logaddr[i] >> 39) & 0x1FF) * 8 ; // Получаем смещение в таблице страниц для 4-го уровня. 
					       // сдвигаем логический адрес на 39 бит вправо. На 4-м уровне 9 бит, поэтому маска будет 1FF (9 единиц в младших разрядах, остальные - нули). 
					       // умножаем на 8 потому что записи в таблице страниц имеют длину 8 байт. Соответственно, на адрес записи затрачивается 8 байт.
  printf ("%llu\n",r+offset[i]);
//  fprintf(f_output,"%llu\n",r+offset[i]);
 }
	 




/*
Достаём значение по этому адресу (это физический адрес).
Смотрим значение, которое мы достали.
Проверяем, равен ли бит P единице (бит присутствия, бит 0). Если равен, то продолжаем. Если нет, то выводим Page Fault.
Получаем непосредственно физический адрес (биты 12-51). Этот физический адрес будет указывать на таблицу страниц следующего уровня (уровня 3).
*/
 printf("Записи по этим адресам:\n");
// fprintf(f_output,"Записи по этим адресам:\n");
 for (j=0;j<q;j++){
  for (i=0;i<m;i++){
   calculated_addr=r+offset[j];
   if (calculated_addr==paddr[i]){
    paddr_tmp=paddr[i];
    value_tmp=value[i];
    break;
   }
   value_tmp=0;
  }
  if ((value_tmp & 1) == 1){
   printf("%d - запись %d действительна\n",value_tmp,j+1);
//   fprintf(f_output,"%d - запись %d действительна\n",value_tmp,j+1);
   table_addr[j]=value_tmp;
  }
  else {
   fault_flag[j]=1; 
   printf("%d - fault\n",value_tmp);
//   fprintf(f_output,"%d - fault\n",value_tmp);
  }
 }

 


/*
Далее возвращаемся к логическому адресу и выделяем из него вторую часть (биты 30-38).
Это будет смещение в таблице страниц уровня 3. 
Прибавляем смещение к адресу таблицы страниц уровня 3 и таким образом получаем адрес нужной нам ячейки в этой таблице страниц.
*/
 printf("\nОбработка таблицы уровня 3\n");
 printf("Адреса в таблице страниц:\n");
// fprintf(f_output,"\nОбработка таблицы уровня 3\n");
// fprintf(f_output,"Адреса в таблице страниц:\n");
 for (i=0;i<q;i++){
  if (!fault_flag[i]){
   offset[i]=8 * ((logaddr[i] >> 30) & 0x1FF) ;  // Получаем смещение в таблице страниц для 3-го уровня. 
	 				       // сдвигаем логический адрес на 30 бит вправо. На 3-м уровне 9 бит, поэтому маска будет 1FF (9 единиц в младших разрядах, остальные - нули). 
					       // умножаем на 8 потому что записи в таблице страниц имеют длину 8 байт. Соответственно, адреса записей кратны 8-ми.
   printf ("%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
//   fprintf (f_output,"%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }



/*
Достаём значение по этому адресу (это физический адрес).
Смотрим значение, которое мы достали.
Проверяем, равен ли бит P единице (бит присутствия, бит 0). Если равен, то продолжаем. Если нет, то выводим Page Fault.
Получаем непосредственно физический адрес (биты 12-51). Этот физический адрес будет указывать на таблицу страниц следующего уровня (уровня 2).
*/
 printf("Записи по этим адресам:\n");
// fprintf(f_output,"Записи по этим адресам:\n");
 for (j=0;j<q;j++){
  if (!fault_flag[j]){
   for (i=0;i<m;i++){
    calculated_addr=(table_addr[j] & 0xFFFFFFFFFFFFF000)  +offset[j];
     if (calculated_addr==paddr[i]){
      paddr_tmp=paddr[i];
      value_tmp=value[i];
      break;
     }
     value_tmp=0;
   }
   if ((value_tmp & 1) == 1){
    printf("%d - запись %d действительна\n",value_tmp,j+1);
//    fprintf(f_output,"%d - запись %d действительна\n",value_tmp,j+1);
    table_addr[j]=value_tmp;
   }
   else {
    fault_flag[j]=1; 
    printf("%d - fault\n",value_tmp);
//    fprintf(f_output,"%d - fault\n",value_tmp);
   }
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }




/*
Далее возвращаемся к логическому адресу и выделяем из него третью часть (биты 21-29).
Это будет смещение в таблице страниц уровня 2.
Прибавляем смещение к адресу таблицы страниц уровня 2 и таким образом получаем адрес нужной нам ячейки в этой таблице страниц.
*/
 printf("\nОбработка таблицы уровня 2\n");
 printf("Адреса в таблице страниц:\n");
// fprintf(f_output,"\nОбработка таблицы уровня 2\n");
// fprintf(f_output,"Адреса в таблице страниц:\n");
 for (i=0;i<q;i++){
  if (!fault_flag[i]){
   offset[i]=8 * ((logaddr[i] >> 21) & 0x1FF) ;  // Получаем смещение в таблице страниц для 2-го уровня. 
	 				       // сдвигаем логический адрес на 21 бит вправо. На 2-м уровне 9 бит, поэтому маска будет 1FF (9 единиц в младших разрядах, остальные - нули). 
					       // умножаем на 8 потому что записи в таблице страниц имеют длину 8 байт. Соответственно, адреса записей кратны 8-ми.

   printf ("%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
//   fprintf (f_output,"%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }

 
/* 
Достаём значение по этому адресу (это физический адрес).
Смотрим значение, которое мы достали.
Проверяем, равен ли бит P единице (бит присутствия, бит 0). Если равен, то продолжаем. Если нет, то выводим Page Fault.
Получаем непосредственно физический адрес (биты 12-51). Этот физический адрес будет указывать на таблицу страниц следующего уровня (уровня 1).
*/
 printf("Записи по этим адресам:\n");
// fprintf(f_output,"Записи по этим адресам:\n");
 for (j=0;j<q;j++){
  if (!fault_flag[j]){
   for (i=0;i<m;i++){
    calculated_addr=(table_addr[j] & 0xFFFFFFFFFFFFF000)  +offset[j];
    if (calculated_addr==paddr[i]){
     paddr_tmp=paddr[i];
     value_tmp=value[i];
     break;
    }
    value_tmp=0;
   }
   if ((value_tmp & 1) == 1){
    printf("%d - запись %d действительна\n",value_tmp,j+1);
//    fprintf(f_output,"%d - запись %d действительна\n",value_tmp,j+1);
    table_addr[j]=value_tmp;
   }
   else {
    fault_flag[j]=1; 
    printf("%d - fault\n",value_tmp);
//    fprintf(f_output,"%d - fault\n",value_tmp);
   }
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }
 

/*
Далее возвращаемся к логическому адресу и выделяем из него четвёртую часть (биты 12-20).
Это будет смещение в таблице страниц уровня 1.
Прибавляем смещение к адресу таблицы страниц уровня 1 и таким образом получаем адрес нужной нам ячейки в этой таблице страниц.
*/
 printf("\nОбработка таблицы уровня 1\n");
 printf("Адреса в таблице страниц:\n");
// fprintf(f_output,"\nОбработка таблицы уровня 1\n");
// fprintf(f_output,"Адреса в таблице страниц:\n");
 for (i=0;i<q;i++){
  if (!fault_flag[i]){
   offset[i]=8 * ((logaddr[i] >> 12) & 0x1FF) ;  // Получаем смещение в таблице страниц для 1-го уровня. 
					       // сдвигаем логический адрес на 12 бит вправо. На 1-м уровне 9 бит, поэтому маска будет 1FF (9 единиц в младших разрядах, остальные - нули). 
					       // умножаем на 8 потому что записи в таблице страниц имеют длину 8 байт. Соответственно, адреса записей кратны 8-ми.

   printf ("%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
//   fprintf (f_output,"%llu\n",(table_addr[i] & 0xFFFFFFFFFFFFF000) + offset[i]);
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }



/* 
Достаём значение по этому адресу (это физический адрес).
Смотрим значение, которое мы достали.
Проверяем, равен ли бит P единице (бит присутствия, бит 0). Если равен, то продолжаем. Если нет, то выводим Page Fault.
Получаем непосредственно физический адрес (биты 12-51). Этот физический адрес будет указывать на таблицу страниц следующего уровня (уровня 0).
*/
 printf("Записи по этим адресам:\n");
// fprintf(f_output,"Записи по этим адресам:\n");
 for (j=0;j<q;j++){
  if (!fault_flag[j]){
   for (i=0;i<m;i++){
    calculated_addr=(table_addr[j] & 0xFFFFFFFFFFFFF000)  +offset[j];
    if (calculated_addr==paddr[i]){
     paddr_tmp=paddr[i];
     value_tmp=value[i];
     break;
    }
    value_tmp=0;
   }
   if ((value_tmp & 1) == 1){
    printf("%d - запись %d действительна\n",value_tmp,j+1);
//    fprintf(f_output,"%d - запись %d действительна\n",value_tmp,j+1);
    table_addr[j]=value_tmp;
   }
   else {
    fault_flag[j]=1; 
    printf("%d - fault\n",value_tmp);
//    fprintf(f_output,"%d - fault\n",value_tmp);
   }
  }
  else {
   printf("fault\n");  
//   fprintf(f_output,"fault\n");
  }  
 }


/*
Далее возвращаемся к логическому адресу и выделяем из него пятую часть (биты 0-11, поэтому маска FFF).
Это будет смещение в таблице страниц уровня 0.
Прибавляем смещение к адресу таблицы страниц уровня 0 и таким образом получаем адрес нужной нам ячейки в этой таблице страниц.
*/
 printf("\nОбработка таблицы уровня 0\n");
 printf("Смещения, добавляемые к адресам:\n");
// fprintf(f_output,"\nОбработка таблицы уровня 0\n");
// fprintf(f_output,"Смещения, добавляемые к адресам:\n");
 for (i=0;i<q;i++){
  if (!fault_flag[i]){
   offset[i]=(logaddr[i] >> 0) & 0xFFF ; // Получаем смещение в таблице страниц для 0-го уровня. 
				       // сдвигаем логический адрес на 0 бит вправо (не сдвигаем). На 0-м уровне 12 бит, поэтому маска будет FFF (12 единиц в младших разрядах, остальные - нули). 
				       // добавлять уже будем к физическому адресу, получив таким образом адрес искомой ячейки памяти

   printf ("%llu\n",offset[i]);
//   fprintf (f_output,"%llu\n",offset[i]);
  }
  else {
   printf("fault\n");
//   fprintf(f_output,"fault\n");
  }
 }

  
  
 printf("Физические адреса:\n"); 
// fprintf(f_output,"Физические адреса:\n"); 
 for (j=0;j<q;j++){
  if (!fault_flag[j]){ 
   value_tmp=(table_addr[j] & 0xFFFFFFFFFFFFF000) +offset[j];
   printf("%d - физический адрес %d \n",value_tmp,j+1);
   fprintf(f_output,"%d\n",value_tmp);
  }
  else {
   printf("fault\n"); 
   fprintf(f_output,"fault\n");
  } 
 }

 // Освобождение памяти
 free(logaddr);
 free(offset);
 free(paddr_converted);
 free(table_addr);
 free(fault_flag);
 fclose(f); // Закрываем файл
}
